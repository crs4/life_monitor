# Default values for chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

hostname: &hostname lm

# name override
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""


lifemonitor:
  replicaCount: 1

  image:
    repository: crs4/lifemonitor
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 8000

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
      #nginx.ingress.kubernetes.io/rewrite-target: /
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: *hostname
        paths:
          - /
    tls:
      - secretName: lifemonitor-tls
        hosts:
          - *hostname

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}


postgresql:
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: 11.10.0-debian-10-r9
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

    ## Set to true if you would like to see extra information on logs
    ## It turns BASH and NAMI debugging in minideb
    ## ref:  https://github.com/bitnami/minideb-extras/#turn-on-bash-debugging
    ##
    debug: false

  ## PostgreSQL admin password (used when `postgresqlUsername` is not `postgres`)
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-user-on-first-run (see note!)
  # postgresqlPostgresPassword:

  ## PostgreSQL user (has superuser privileges if username is `postgres`)
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
  ##
  postgresqlUsername: &dbuser lm

  ## PostgreSQL password
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
  ##
  postgresqlPassword: &dbpassword foobar

  ## PostgreSQL password using existing secret
  ## existingSecret: secret
  ##

  ## Mount PostgreSQL secret as a file instead of passing environment variable
  # usePasswordFile: false

  ## Create a database
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-on-first-run
  ##
  postgresqlDatabase: &dbname lm

  ## PostgreSQL data dir
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
  ##
  postgresqlDataDir: /bitnami/postgresql/data

  ## An array to add extra environment variables
  ## For example:
  ## extraEnv:
  ##   - name: FOO
  ##     value: "bar"
  ##
  # extraEnv:
  extraEnv: []

  ## Name of a ConfigMap containing extra env vars
  ##
  # extraEnvVarsCM:

  ## Specify extra initdb args
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
  ##
  # postgresqlInitdbArgs:

  ## Specify a custom location for the PostgreSQL transaction log
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
  ##
  # postgresqlInitdbWalDir:

  ## PostgreSQL configuration
  ## Specify runtime configuration parameters as a dict, using camelCase, e.g.
  ## {"sharedBuffers": "500MB"}
  ## Alternatively, you can put your postgresql.conf under the files/ directory
  ## ref: https://www.postgresql.org/docs/current/static/runtime-config.html
  ##
  # postgresqlConfiguration:

  ## PostgreSQL extended configuration
  ## As above, but _appended_ to the main configuration
  ## Alternatively, you can put your *.conf under the files/conf.d/ directory
  ## https://github.com/bitnami/bitnami-docker-postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf
  ##
  # postgresqlExtendedConf:

  ## PostgreSQL service configuration
  ##
  service:
    ## PosgresSQL service type
    ##
    type: ClusterIP
    # clusterIP: None
    port: 5432

    ## Specify the nodePort value for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    # nodePort:

    ## Provide any additional annotations which may be required. Evaluated as a template.
    ##
    annotations: {}
    ## Set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    # loadBalancerIP:
    ## Load Balancer sources. Evaluated as a template.
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ##
    # loadBalancerSourceRanges:
    # - 10.10.10.0/24

  ## PostgreSQL data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  persistence:
    enabled: true
    ## A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template, so, for example, the name can depend on .Release or .Chart
    ##
    # existingClaim:

    ## The path the volume will be mounted at, useful when using different
    ## PostgreSQL images.
    ##
    mountPath: /bitnami/postgresql

    ## The subdirectory of the volume to mount to, useful in dev environments
    ## and one PV for multiple services.
    ##
    subPath: ''

    storageClass: "-"
    accessModes:
      - ReadWriteOnce
    size: 8Gi
    annotations: {}
    ## selector can be used to match an existing PersistentVolume
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    selector: {}
